# File: docker-compose.dev.yml
version: '3.8'

services:
  postgres_db:
    image: postgis/postgis:15-3.3 # PostgreSQL with PostGIS extension
    container_name: seattle_info_postgres_dev
    ports:
      - "${DB_PORT:-5432}:5432" # Use DB_PORT from .env or default to 5432
    environment:
      POSTGRES_USER: ${DB_USER:-your_db_user} # Use from .env or default
      POSTGRES_PASSWORD: ${DB_PASSWORD:-your_db_password} # Use from .env or default
      POSTGRES_DB: ${DB_NAME:-seattle_info_db} # Use from .env or default
    volumes:
      - postgres_data_dev:/var/lib/postgresql/data
    networks:
      - seattle_info_net_dev
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-your_db_user} -d ${DB_NAME:-seattle_info_db}"]
      interval: 10s
      timeout: 5s
      retries: 5

  pgadmin:
    image: dpage/pgadmin4:8.6
    container_name: seattle_info_pgadmin_dev
    environment:
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_EMAIL:-admin@admin.com}
      PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_PASSWORD:-admin}
    ports:
      - "5050:80" # Access pgAdmin at http://localhost:5050
    depends_on:
      - postgres_db
    networks:
      - seattle_info_net_dev
    restart: unless-stopped
    volumes:
      - pgadmin_data_dev:/var/lib/pgadmin

  migrate:
    image: migrate/migrate:v4.16.2
    container_name: seattle_info_migrate_dev
    volumes:
      - ./migrations:/migrations
    networks:
      - seattle_info_net_dev
    entrypoint: ["/bin/sh", "-c"]
    command: ["echo", "Ready for migration commands"] # This will be overridden
    depends_on:
      postgres_db: # Corrected way to specify service dependency
        condition: service_healthy # Wait for healthcheck to pass
    env_file: # Ensure migrate service also uses .env.dev for DB_SOURCE by default
      - ./.env.dev
    environment:
      # DB_SOURCE will be taken from .env.dev.
      # If passed via `docker compose run -e DB_SOURCE=...`, that would override.
      - DB_SOURCE=${DB_SOURCE}

  # Go application service (optional for now, can be run locally)
  # If you want to run the Go app in Docker during development:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: seattle_info_app_dev
    ports:
      - "${SERVER_PORT:-8080}:${SERVER_PORT:-8080}" # SERVER_PORT will be sourced from .env.dev
    depends_on:
      postgres_db:
        condition: service_healthy
    env_file:
      - ./.env.dev # Load development environment variables
    volumes:
      - .:/app # Mount current directory to /app in container for live code changes
    networks:
      - seattle_info_net_dev
    # For development, we want to run the application using go run for faster iteration
    # Ensure wire_gen.go is up to date (make wire)
    command: ["go", "run", "./cmd/server/main.go", "./cmd/server/wire_gen.go"]
    # If you prefer hot-reloading with a tool like Air:
    # command: ["air", "-c", ".air.toml"] # Requires Air setup

volumes:
  postgres_data_dev:
    driver: local
  pgadmin_data_dev:
    driver: local

networks:
  seattle_info_net_dev:
    driver: bridge
