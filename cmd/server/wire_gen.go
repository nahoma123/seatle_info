// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	elasticsearch2 "github.com/elastic/go-elasticsearch/v8"
	"go.uber.org/zap"
	"gorm.io/gorm"
	"log"
	"seattle_info_backend/internal/app"
	"seattle_info_backend/internal/auth"
	"seattle_info_backend/internal/category"
	"seattle_info_backend/internal/config"
	"seattle_info_backend/internal/firebase"
	"seattle_info_backend/internal/jobs"
	"seattle_info_backend/internal/listing"
	"seattle_info_backend/internal/notification"
	"seattle_info_backend/internal/platform/database"
	"seattle_info_backend/internal/platform/elasticsearch"
	"seattle_info_backend/internal/platform/logger"
	"seattle_info_backend/internal/user"
)

// Injectors from wire.go:

// initializeServer is the main Wire injector.
// Signature reverted to (*app.Server, func(), error) as ESClient & Logger are now in Server struct
func initializeServer(cfg *config.Config) (*app.Server, func(), error) {
	zapLogger, err := logger.New(cfg)
	if err != nil {
		return nil, nil, err
	}
	db, err := database.NewGORM(cfg)
	if err != nil {
		return nil, nil, err
	}
	repository := user.NewGORMRepository(db)
	serviceImplementation := user.NewService(repository, cfg, zapLogger)
	handler := user.NewHandler(serviceImplementation, zapLogger)
	authHandler := auth.NewHandler(serviceImplementation, zapLogger)
	categoryRepository := category.NewGORMRepository(db)
	service := category.NewService(categoryRepository, zapLogger, cfg)
	categoryHandler := category.NewHandler(service, zapLogger)
	listingRepository := listing.NewGORMRepository(db)
	notificationRepository := notification.NewGORMRepository(db)
	notificationService := notification.NewService(notificationRepository, zapLogger)
	esClientWrapper, err := elasticsearch.NewClient(cfg, zapLogger)
	if err != nil {
		return nil, nil, err
	}
	listingService := listing.NewService(listingRepository, repository, service, notificationService, cfg, zapLogger, esClientWrapper)
	listingHandler := listing.NewHandler(listingService, zapLogger)
	notificationHandler := notification.NewHandler(notificationService, zapLogger)
	listingExpiryJob := jobs.NewListingExpiryJob(listingService, zapLogger, cfg)
	firebaseService, err := firebase.NewFirebaseService(cfg, zapLogger)
	if err != nil {
		return nil, nil, err
	}
	server, err := app.NewServer(cfg, zapLogger, handler, authHandler, categoryHandler, listingHandler, notificationHandler, listingExpiryJob, db, firebaseService, serviceImplementation, esClientWrapper)
	if err != nil {
		return nil, nil, err
	}
	return server, func() {
	}, nil
}

// wire.go:

// Dummy variables
var _ *elasticsearch.ESClientWrapper

var _ *elasticsearch2.Client

// provideCleanup is defined but NOT included in wire.Build above.
// Wire will generate its own cleanup function.
func provideCleanup(logger2 *zap.Logger, db *gorm.DB) func() {
	return func() {
		logger2.
			Info("Executing cleanup tasks...")
		database.CloseGORMDB(db)
		if err := logger2.Sync(); err != nil {
			log.Printf("ERROR: Failed to sync logger during cleanup: %v", err)
		}
		log.Println("Cleanup finished.")
	}
}
